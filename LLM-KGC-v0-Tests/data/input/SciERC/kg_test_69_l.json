{
  "iri": "Paper-69",
  "title": "E91-1012",
  "authors": [],
  "keywords": [],
  "sections": [
    {
      "iri": "Paper-69-Section-1",
      "subtitle": "Abstract",
      "paragraphs": [
        {
          "iri": "Paper-69-Section-1-Paragraph-1",
          "sentences": [
            {
              "iri": "Paper-69-Section-1-Paragraph-1-Sentence-1",
              "text": "A purely functional implementation of LR-parsers is given , together with a simple correctness proof ."
            },
            {
              "iri": "Paper-69-Section-1-Paragraph-1-Sentence-2",
              "text": "It is presented as a generalization of the recursive descent parser ."
            },
            {
              "iri": "Paper-69-Section-1-Paragraph-1-Sentence-3",
              "text": "For non-LR grammars the time-complexity of our parser is cubic if the functions that constitute the parser are implemented as memo-functions , i.e. functions that memorize the results of previous invocations ."
            },
            {
              "iri": "Paper-69-Section-1-Paragraph-1-Sentence-4",
              "text": "Memo-functions also facilitate a simple way to construct a very compact representation of the parse forest ."
            },
            {
              "iri": "Paper-69-Section-1-Paragraph-1-Sentence-5",
              "text": "For LR -LRB- 0 -RRB- grammars , our algorithm is closely related to the recursive ascent parsers recently discovered by Kruse-man Aretz -LSB- 1 -RSB- and Roberts -LSB- 2 -RSB- ."
            },
            {
              "iri": "Paper-69-Section-1-Paragraph-1-Sentence-6",
              "text": "Extended CF grammars -LRB- grammars with regular expressions at the right hand side -RRB- can be parsed with a simple modification of the LR-parser for normal CF grammars ."
            }
          ]
        }
      ]
    }
  ],
  "times": [
    0.0005054473876953125,
    16.48811364173889,
    21.41896152496338,
    21.270516872406006,
    0.02008509635925293,
    9.083747863769531e-05,
    0.00010776519775390625,
    28.67917490005493,
    46.12180304527283,
    1.074174165725708,
    43.57323455810547,
    0.008451700210571289,
    0.00018215179443359375,
    29.191542387008667,
    2.3546273708343506,
    0.015773534774780273,
    1.0922539234161377,
    3.44150972366333,
    3.147352457046509,
    3.515470027923584,
    28.910788774490356,
    1.5595502853393555,
    15.005128145217896,
    0.7710742950439453,
    0.000461578369140625,
    0.010088682174682617
  ],
  "nodes": {
    "Entity-for_non-lr_grammar": {
      "node_id": "for_non-lr_grammar",
      "disambiguation_index": 0,
      "label": "For non-LR grammars",
      "aliases": [
        "For non-LR grammars"
      ],
      "types": [
        "grammar"
      ],
      "node_type": "other",
      "LLM_familiarity": false,
      "description": "The time complexity of our parser is cubic when implemented as memo-functions, memorizing previous invocations.",
      "mentions": [
        {
          "reference": "Paper-69-Section-1-Paragraph-1-Sentence-3",
          "local_name": "For non-LR grammars",
          "local_types": [
            "grammar"
          ],
          "iri": "Entity-for_non-lr_grammar-Mention-1"
        }
      ],
      "relevance": 0.75341796875
    },
    "Entity-the_recursive_ascent_parser": {
      "node_id": "the_recursive_ascent_parser",
      "disambiguation_index": 0,
      "label": "the recursive ascent parsers",
      "aliases": [
        "the recursive ascent parsers"
      ],
      "types": [
        "parser"
      ],
      "node_type": "other",
      "LLM_familiarity": true,
      "description": "A type of parser that recursively ascends through a grammar to parse LR-LRB-0-RRB- grammars, recently discovered by Kruse-man Aretz and Roberts.",
      "mentions": [
        {
          "reference": "Paper-69-Section-1-Paragraph-1-Sentence-5",
          "local_name": "the recursive ascent parsers",
          "local_types": [
            "parser"
          ],
          "iri": "Entity-the_recursive_ascent_parser-Mention-1"
        }
      ],
      "relevance": 0.734375
    },
    "Entity-the_time-complexity_of_our_parser_is_cubic": {
      "node_id": "the_time-complexity_of_our_parser_is_cubic",
      "disambiguation_index": 0,
      "label": "the time-complexity of our parser is cubic",
      "aliases": [
        "the time-complexity of our parser is cubic"
      ],
      "types": [
        "complexity"
      ],
      "node_type": "other",
      "LLM_familiarity": true,
      "description": "The time complexity of our parsing algorithm for non-LR grammars when implemented with memo-functions.",
      "mentions": [
        {
          "reference": "Paper-69-Section-1-Paragraph-1-Sentence-3",
          "local_name": "the time-complexity of our parser is cubic",
          "local_types": [
            "complexity"
          ],
          "iri": "Entity-the_time-complexity_of_our_parser_is_cubic-Mention-1"
        }
      ],
      "relevance": 0.720703125
    },
    "Entity-non-lr_grammar": {
      "node_id": "non-lr_grammar",
      "disambiguation_index": 0,
      "label": "non-LR grammars",
      "aliases": [
        "non-LR grammars"
      ],
      "types": [
        "grammar"
      ],
      "node_type": "general term",
      "LLM_familiarity": false,
      "description": "A type of grammar that cannot be parsed using LR-parser algorithms, requiring memo-functions to achieve cubic time-complexity.",
      "mentions": [
        {
          "reference": "Paper-69-Section-1-Paragraph-1-Sentence-3",
          "local_name": "non-LR grammars",
          "local_types": [
            "grammar"
          ],
          "iri": "Entity-non-lr_grammar-Mention-1"
        }
      ],
      "relevance": 0.71044921875
    },
    "Entity-for_lr_-lrb-_0_-rrb-_grammar": {
      "node_id": "for_lr_-lrb-_0_-rrb-_grammar",
      "disambiguation_index": 0,
      "label": "For LR -LRB- 0 -RRB- grammars",
      "aliases": [
        "For LR -LRB- 0 -RRB- grammars"
      ],
      "types": [
        "grammar"
      ],
      "node_type": "other",
      "LLM_familiarity": false,
      "description": "A type of grammar that can be parsed using the LR-parser algorithm, characterized by a specific set of rules and constraints.",
      "mentions": [
        {
          "reference": "Paper-69-Section-1-Paragraph-1-Sentence-5",
          "local_name": "For LR -LRB- 0 -RRB- grammars",
          "local_types": [
            "grammar"
          ],
          "iri": "Entity-for_lr_-lrb-_0_-rrb-_grammar-Mention-1"
        }
      ],
      "relevance": 0.6669921875
    },
    "Entity-lr-parser": {
      "node_id": "lr-parser",
      "disambiguation_index": 0,
      "label": "LR-parser",
      "aliases": [
        "LR-parser"
      ],
      "types": [
        "parser",
        "algorithm"
      ],
      "node_type": "general term",
      "LLM_familiarity": true,
      "description": "A parsing algorithm that uses Left-to-Right (LR) parsing techniques to analyze and interpret input strings according to a given grammar.",
      "mentions": [
        {
          "reference": "Paper-69-Section-1-Paragraph-1-Sentence-6",
          "local_name": "LR-parser",
          "local_types": [
            "parser",
            "algorithm"
          ],
          "iri": "Entity-lr-parser-Mention-1"
        }
      ],
      "relevance": 0.658203125
    },
    "Entity-a_generalization_of_the_recursive_descent_parser": {
      "node_id": "a_generalization_of_the_recursive_descent_parser",
      "disambiguation_index": 0,
      "label": "a generalization of the recursive descent parser",
      "aliases": [
        "a generalization of the recursive descent parser"
      ],
      "types": [
        "generalization",
        "concept"
      ],
      "node_type": "other",
      "LLM_familiarity": true,
      "description": "A parsing algorithm that extends and simplifies the functionality of the recursive descent parser, allowing for efficient processing of various grammar types.",
      "mentions": [
        {
          "reference": "Paper-69-Section-1-Paragraph-1-Sentence-2",
          "local_name": "a generalization of the recursive descent parser",
          "local_types": [
            "generalization",
            "concept"
          ],
          "iri": "Entity-a_generalization_of_the_recursive_descent_parser-Mention-1"
        }
      ],
      "relevance": 0.65771484375
    },
    "Entity-lr-parsers": {
      "node_id": "lr-parsers",
      "disambiguation_index": 0,
      "label": "LR-parsers",
      "aliases": [
        "LR-parsers"
      ],
      "types": [
        "theory",
        "algorithm",
        "parser",
        "computational model",
        "computer science",
        "concept",
        "parsing",
        "parsing technique",
        "parsing algorithm"
      ],
      "node_type": "named entity",
      "LLM_familiarity": true,
      "description": "A parsing technique or algorithm that uses Left Recursion to parse strings.",
      "mentions": [
        {
          "reference": "Paper-69-Section-1-Paragraph-1-Sentence-1",
          "local_name": "LR-parsers",
          "local_types": [
            "theory",
            "algorithm",
            "parser",
            "computational model",
            "computer science",
            "concept",
            "parsing",
            "parsing technique",
            "parsing algorithm"
          ],
          "iri": "Entity-lr-parsers-Mention-1"
        }
      ],
      "relevance": 0.64599609375
    },
    "Entity-a_simple_way_to_construct_a_very_compact_representation_of_the_parse_forest": {
      "node_id": "a_simple_way_to_construct_a_very_compact_representation_of_the_parse_forest",
      "disambiguation_index": 0,
      "label": "a simple way to construct a very compact representation of the parse forest",
      "aliases": [
        "a simple way to construct a very compact representation of the parse forest"
      ],
      "types": [
        "methodology"
      ],
      "node_type": "other",
      "LLM_familiarity": false,
      "description": "A method for constructing a concise representation of the parse tree, made possible by memo-functions.",
      "mentions": [
        {
          "reference": "Paper-69-Section-1-Paragraph-1-Sentence-4",
          "local_name": "a simple way to construct a very compact representation of the parse forest",
          "local_types": [
            "methodology"
          ],
          "iri": "Entity-a_simple_way_to_construct_a_very_compact_representation_of_the_parse_forest-Mention-1"
        }
      ],
      "relevance": 0.64306640625
    },
    "Entity-recursive_ascent_parser": {
      "node_id": "recursive_ascent_parser",
      "disambiguation_index": 0,
      "label": "recursive ascent parsers",
      "aliases": [
        "recursive ascent parsers",
        "our algorithm"
      ],
      "types": [
        "parser",
        "algorithm"
      ],
      "node_type": "general term",
      "LLM_familiarity": true,
      "description": "A type of parser that uses recursive descent parsing techniques to analyze grammatical structures.",
      "mentions": [
        {
          "reference": "Paper-69-Section-1-Paragraph-1-Sentence-5",
          "local_name": "recursive ascent parsers",
          "local_types": [
            "algorithm",
            "parser"
          ],
          "iri": "Entity-recursive_ascent_parser-Mention-1"
        },
        {
          "reference": "Paper-69-Section-1-Paragraph-1-Sentence-5",
          "local_name": "our algorithm",
          "local_types": [
            "algorithm"
          ],
          "iri": "Entity-recursive_ascent_parser-Mention-2"
        }
      ],
      "relevance": 0.6376953125
    },
    "Entity-recursive_descent_parser": {
      "node_id": "recursive_descent_parser",
      "disambiguation_index": 0,
      "label": "recursive descent parser",
      "aliases": [
        "the recursive descent parser",
        "recursive descent parser"
      ],
      "types": [
        "theory",
        "algorithm",
        "parser",
        "parser type",
        "parsing",
        "computing paradigm",
        "computing concept"
      ],
      "node_type": "named entity",
      "LLM_familiarity": true,
      "description": "A parsing algorithm that uses a set of rules to recursively analyze and break down input strings into their constituent parts.",
      "mentions": [
        {
          "reference": "Paper-69-Section-1-Paragraph-1-Sentence-2",
          "local_name": "recursive descent parser",
          "local_types": [
            "theory",
            "algorithm",
            "parser",
            "parser type",
            "parsing",
            "computing paradigm",
            "computing concept"
          ],
          "iri": "Entity-recursive_descent_parser-Mention-1"
        },
        {
          "reference": "Paper-69-Section-1-Paragraph-1-Sentence-2",
          "local_name": "the recursive descent parser",
          "local_types": [
            "parser"
          ],
          "iri": "Entity-recursive_descent_parser-Mention-2"
        }
      ],
      "relevance": 0.609375
    },
    "Entity-a_purely_functional_implementation": {
      "node_id": "a_purely_functional_implementation",
      "disambiguation_index": 0,
      "label": "A purely functional implementation",
      "aliases": [
        "A purely functional implementation"
      ],
      "types": [
        "implementation"
      ],
      "node_type": "other",
      "LLM_familiarity": true,
      "description": "An algorithm or program that implements the LR-parser parsing technique using only pure functions and does not use mutable state.",
      "mentions": [
        {
          "reference": "Paper-69-Section-1-Paragraph-1-Sentence-1",
          "local_name": "A purely functional implementation",
          "local_types": [
            "implementation"
          ],
          "iri": "Entity-a_purely_functional_implementation-Mention-1"
        }
      ],
      "relevance": 0.60009765625
    },
    "Entity-if_the_function_that_constitute_the_parser_are_implemented_a_memo-functions__i.e_._function_that_memorize_the_result_of_previous_invocation": {
      "node_id": "if_the_function_that_constitute_the_parser_are_implemented_a_memo-functions__i.e_._function_that_memorize_the_result_of_previous_invocation",
      "disambiguation_index": 0,
      "label": "if the functions that constitute the parser are implemented as memo-functions, i.e. functions that memorize the results of previous invocations",
      "aliases": [
        "if the functions that constitute the parser are implemented as memo-functions, i.e. functions that memorize the results of previous invocations"
      ],
      "types": [
        "implementation detail"
      ],
      "node_type": "other",
      "LLM_familiarity": false,
      "description": "The implementation detail where the parser's constituent functions use memoization to store and reuse previously computed results.",
      "mentions": [
        {
          "reference": "Paper-69-Section-1-Paragraph-1-Sentence-3",
          "local_name": "if the functions that constitute the parser are implemented as memo-functions, i.e. functions that memorize the results of previous invocations",
          "local_types": [
            "implementation detail"
          ],
          "iri": "Entity-if_the_function_that_constitute_the_parser_are_implemented_a_memo-functions__i.e_._function_that_memorize_the_result_of_previous_invocation-Mention-1"
        }
      ],
      "relevance": 0.59326171875
    },
    "Entity-kruse-man_aretz": {
      "node_id": "kruse-man_aretz",
      "disambiguation_index": 0,
      "label": "Kruse-man Aretz",
      "aliases": [
        "Kruse-man Aretz"
      ],
      "types": [
        "author"
      ],
      "node_type": "other",
      "LLM_familiarity": false,
      "description": "Kruse-man Aretz, a researcher who discovered recursive ascent parsers.",
      "mentions": [
        {
          "reference": "Paper-69-Section-1-Paragraph-1-Sentence-5",
          "local_name": "Kruse-man Aretz",
          "local_types": [
            "author"
          ],
          "iri": "Entity-kruse-man_aretz-Mention-1"
        }
      ],
      "relevance": 0.5927734375
    },
    "Entity-extended_cf_grammar": {
      "node_id": "extended_cf_grammar",
      "disambiguation_index": 0,
      "label": "Extended CF grammars",
      "aliases": [
        "Extended CF grammars"
      ],
      "types": [
        "computational theory",
        "grammar",
        "concept"
      ],
      "node_type": "named entity",
      "LLM_familiarity": true,
      "description": "A type of grammar that extends context-free (CF) grammars to include regular expressions in their right-hand sides.",
      "mentions": [
        {
          "reference": "Paper-69-Section-1-Paragraph-1-Sentence-6",
          "local_name": "Extended CF grammars",
          "local_types": [
            "computational theory",
            "grammar",
            "concept"
          ],
          "iri": "Entity-extended_cf_grammar-Mention-1"
        }
      ],
      "relevance": 0.5869140625
    },
    "Entity--lrb-": {
      "node_id": "-lrb-",
      "disambiguation_index": 0,
      "label": "-LRB-",
      "aliases": [
        "-LRB-"
      ],
      "types": [
        "punctuation mark",
        "notation"
      ],
      "node_type": "named entity",
      "LLM_familiarity": false,
      "description": "LR notation, used to denote left and right brackets in Extended CF grammars",
      "mentions": [
        {
          "reference": "Paper-69-Section-1-Paragraph-1-Sentence-6",
          "local_name": "-LRB-",
          "local_types": [
            "punctuation mark",
            "notation"
          ],
          "iri": "Entity--lrb--Mention-1"
        }
      ],
      "relevance": 0.56884765625
    },
    "Entity-grammar_with_regular_expression_at_the_right_hand_side": {
      "node_id": "grammar_with_regular_expression_at_the_right_hand_side",
      "disambiguation_index": 0,
      "label": "grammars with regular expressions at the right hand side",
      "aliases": [
        "grammars with regular expressions at the right hand side"
      ],
      "types": [
        "notation"
      ],
      "node_type": "other",
      "LLM_familiarity": true,
      "description": "A type of grammar that extends context-free (CF) grammars by allowing regular expressions at the right-hand side.",
      "mentions": [
        {
          "reference": "Paper-69-Section-1-Paragraph-1-Sentence-6",
          "local_name": "grammars with regular expressions at the right hand side",
          "local_types": [
            "notation"
          ],
          "iri": "Entity-grammar_with_regular_expression_at_the_right_hand_side-Mention-1"
        }
      ],
      "relevance": 0.5634765625
    },
    "Entity-a_simple_correctness_proof": {
      "node_id": "a_simple_correctness_proof",
      "disambiguation_index": 0,
      "label": "a simple correctness proof",
      "aliases": [
        "a simple correctness proof"
      ],
      "types": [
        "proof"
      ],
      "node_type": "other",
      "LLM_familiarity": true,
      "description": "A formal demonstration or justification that confirms the accuracy and validity of an LR-parser's functionality.",
      "mentions": [
        {
          "reference": "Paper-69-Section-1-Paragraph-1-Sentence-1",
          "local_name": "a simple correctness proof",
          "local_types": [
            "proof"
          ],
          "iri": "Entity-a_simple_correctness_proof-Mention-1"
        }
      ],
      "relevance": 0.56201171875
    },
    "Entity-memo-functions": {
      "node_id": "memo-functions",
      "disambiguation_index": 0,
      "label": "memo-functions",
      "aliases": [
        "Memo-functions",
        "memo-functions"
      ],
      "types": [
        "programming technique",
        "notation",
        "optimization",
        "concept",
        "memory management",
        "functionality"
      ],
      "node_type": "general term",
      "LLM_familiarity": true,
      "description": "Memo-functions refer to programming techniques or notations that optimize function calls by storing and reusing previously computed results.",
      "mentions": [
        {
          "reference": "Paper-69-Section-1-Paragraph-1-Sentence-3",
          "local_name": "memo-functions",
          "local_types": [
            "programming technique",
            "optimization",
            "concept",
            "memory management",
            "functionality"
          ],
          "iri": "Entity-memo-functions-Mention-1"
        },
        {
          "reference": "Paper-69-Section-1-Paragraph-1-Sentence-4",
          "local_name": "Memo-functions",
          "local_types": [
            "notation",
            "concept"
          ],
          "iri": "Entity-memo-functions-Mention-2"
        }
      ],
      "relevance": 0.560546875
    },
    "Entity-parse_forest": {
      "node_id": "parse_forest",
      "disambiguation_index": 0,
      "label": "parse forest",
      "aliases": [
        "parse forest"
      ],
      "types": [
        "computer science",
        "parsing output",
        "data structure",
        "computational concept"
      ],
      "node_type": "general term",
      "LLM_familiarity": true,
      "description": "A data structure representing the hierarchical organization of parsed linguistic structures, typically used in natural language processing and computational linguistics.",
      "mentions": [
        {
          "reference": "Paper-69-Section-1-Paragraph-1-Sentence-4",
          "local_name": "parse forest",
          "local_types": [
            "computer science",
            "parsing output",
            "data structure",
            "computational concept"
          ],
          "iri": "Entity-parse_forest-Mention-1"
        }
      ],
      "relevance": 0.548828125
    },
    "Entity-parser": {
      "node_id": "parser",
      "disambiguation_index": 0,
      "label": "parser",
      "aliases": [
        "parser"
      ],
      "types": [
        "software",
        "algorithm"
      ],
      "node_type": "general term",
      "LLM_familiarity": true,
      "description": "A software or algorithm designed to analyze and break down structured data into its constituent parts, often used in natural language processing and computational linguistics.",
      "mentions": [
        {
          "reference": "Paper-69-Section-1-Paragraph-1-Sentence-3",
          "local_name": "parser",
          "local_types": [
            "software",
            "algorithm"
          ],
          "iri": "Entity-parser-Mention-1"
        }
      ],
      "relevance": 0.51904296875
    },
    "Entity-robert": {
      "node_id": "robert",
      "disambiguation_index": 0,
      "label": "Roberts",
      "aliases": [
        "Roberts"
      ],
      "types": [
        "author",
        "academic",
        "person",
        "researcher"
      ],
      "node_type": "named entity",
      "LLM_familiarity": true,
      "description": "A researcher or academic known for their work in linguistics.",
      "mentions": [
        {
          "reference": "Paper-69-Section-1-Paragraph-1-Sentence-5",
          "local_name": "Roberts",
          "local_types": [
            "author",
            "academic",
            "person",
            "researcher"
          ],
          "iri": "Entity-robert-Mention-1"
        }
      ],
      "relevance": 0.4970703125
    },
    "Entity-function": {
      "node_id": "function",
      "disambiguation_index": 0,
      "label": "functions",
      "aliases": [
        "functions"
      ],
      "types": [
        "programming concept",
        "computational unit"
      ],
      "node_type": "general term",
      "LLM_familiarity": true,
      "description": "A self-contained unit of code or logic that performs a specific task, often invoked repeatedly with varying inputs to produce different outputs.",
      "mentions": [
        {
          "reference": "Paper-69-Section-1-Paragraph-1-Sentence-3",
          "local_name": "functions",
          "local_types": [
            "programming concept",
            "computational unit"
          ],
          "iri": "Entity-function-Mention-1"
        }
      ],
      "relevance": 0.49365234375
    },
    "Entity-correctness_proof": {
      "node_id": "correctness_proof",
      "disambiguation_index": 0,
      "label": "correctness proof",
      "aliases": [
        "correctness proof"
      ],
      "types": [
        "mathematical proof",
        "validation process"
      ],
      "node_type": "general term",
      "LLM_familiarity": true,
      "description": "A formal demonstration or validation procedure that ensures the accuracy and soundness of an argument or mathematical statement.",
      "mentions": [
        {
          "reference": "Paper-69-Section-1-Paragraph-1-Sentence-1",
          "local_name": "correctness proof",
          "local_types": [
            "mathematical proof",
            "validation process"
          ],
          "iri": "Entity-correctness_proof-Mention-1"
        }
      ],
      "relevance": 0.45361328125
    },
    "Entity--rrb-": {
      "node_id": "-rrb-",
      "disambiguation_index": 0,
      "label": "-RRB-",
      "aliases": [
        "-RRB-"
      ],
      "types": [
        "punctuation mark",
        "notation"
      ],
      "node_type": "named entity",
      "LLM_familiarity": false,
      "description": "right angle bracket",
      "mentions": [
        {
          "reference": "Paper-69-Section-1-Paragraph-1-Sentence-6",
          "local_name": "-RRB-",
          "local_types": [
            "punctuation mark",
            "notation"
          ],
          "iri": "Entity--rrb--Mention-1"
        }
      ],
      "relevance": 0.450927734375
    },
    "Entity-generalization": {
      "node_id": "generalization",
      "disambiguation_index": 0,
      "label": "generalization",
      "aliases": [
        "generalization"
      ],
      "types": [
        "concept",
        "idea"
      ],
      "node_type": "general term",
      "LLM_familiarity": true,
      "description": "A concept or idea that summarizes and abstracts specific information, often representing a broader principle or pattern.",
      "mentions": [
        {
          "reference": "Paper-69-Section-1-Paragraph-1-Sentence-2",
          "local_name": "generalization",
          "local_types": [
            "concept",
            "idea"
          ],
          "iri": "Entity-generalization-Mention-1"
        }
      ],
      "relevance": 0.42041015625
    },
    "Entity-implementation": {
      "node_id": "implementation",
      "disambiguation_index": 0,
      "label": "implementation",
      "aliases": [
        "implementation"
      ],
      "types": [
        "software development",
        "programming"
      ],
      "node_type": "general term",
      "LLM_familiarity": true,
      "description": "A process or method for putting plans or designs into effect",
      "mentions": [
        {
          "reference": "Paper-69-Section-1-Paragraph-1-Sentence-1",
          "local_name": "implementation",
          "local_types": [
            "software development",
            "programming"
          ],
          "iri": "Entity-implementation-Mention-1"
        }
      ],
      "relevance": 0.407470703125
    }
  },
  "summary": "A purely functional implementation of LR-parsers is given , together with a simple correctness proof . It is presented as a generalization of the recursive descent parser . For non-LR grammars the time-complexity of our parser is cubic if the functions that constitute the parser are implemented as memo-functions , i.e. functions that memorize the results of previous invocations . Memo-functions also facilitate a simple way to construct a very compact representation of the parse forest . For LR -LRB- 0 -RRB- grammars , our algorithm is closely related to the recursive ascent parsers recently discovered by Kruse-man Aretz -LSB- 1 -RSB- and Roberts -LSB- 2 -RSB- . Extended CF grammars -LRB- grammars with regular expressions at the right hand side -RRB- can be parsed with a simple modification of the LR-parser for normal CF grammars .",
  "triples": [
    [
      "Entity-a_purely_functional_implementation",
      "Predicate-gives",
      "Entity-lr-parsers"
    ],
    [
      "Entity-a_purely_functional_implementation",
      "Predicate-provides",
      "Entity-a_simple_correctness_proof"
    ],
    [
      "Entity-a_purely_functional_implementation",
      "Predicate-is_given",
      "Entity-a_simple_correctness_proof"
    ],
    [
      "Entity-memo-functions",
      "Predicate-facilitate",
      "Entity-a_simple_way_to_construct_a_very_compact_representation_of_the_parse_forest"
    ],
    [
      "Entity-recursive_ascent_parser",
      "Predicate-is_closely_related_to",
      "Entity-the_recursive_ascent_parser"
    ],
    [
      "Entity-kruse-man_aretz",
      "Predicate-recently_discovered_by",
      "Entity-robert"
    ],
    [
      "Entity-for_non-lr_grammar",
      "Predicate-can_be_parsed_with",
      "Entity-the_recursive_ascent_parser"
    ]
  ],
  "triples_typing": [
    [
      "Entity-the_recursive_ascent_parser",
      "skos:broader",
      "Entity-parser"
    ],
    [
      "Entity-recursive_ascent_parser",
      "skos:broader",
      "Entity-parser"
    ],
    [
      "Entity-a_purely_functional_implementation",
      "skos:broader",
      "Entity-implementation"
    ],
    [
      "Entity-recursive_descent_parser",
      "skos:broader",
      "Entity-parser"
    ],
    [
      "Entity-lr-parser",
      "skos:broader",
      "Entity-parser"
    ],
    [
      "Entity-lr-parsers",
      "skos:broader",
      "Entity-parser"
    ],
    [
      "Entity-a_generalization_of_the_recursive_descent_parser",
      "skos:broader",
      "Entity-generalization"
    ]
  ],
  "predicates": {
    "Predicate-gives": {
      "label": "gives",
      "description": "The predicate 'gives' indicates a transfer of something from the subject to the object. It implies that the subject provides or offers the object as its own, often with the intention of sharing or making it available.",
      "disambiguation_index": 0
    },
    "Predicate-provides": {
      "label": "provides",
      "description": "The predicate 'provides' indicates that the subject offers or furnishes something (the object), often implying a sense of satisfaction, fulfillment, or meeting a need. It suggests a relationship where the subject has something to offer and makes it available for use or consideration.",
      "disambiguation_index": 0
    },
    "Predicate-is_given": {
      "label": "is given",
      "description": "The predicate 'is given' indicates that something (the subject) has been provided or offered as a contribution to a particular context. It establishes a connection between the subject and object by implying that the object is being presented, proposed, or made available for consideration.",
      "disambiguation_index": 0
    },
    "Predicate-facilitate": {
      "label": "facilitate",
      "description": "To facilitate means to make something easier or more efficient by providing support, resources, or guidance. It implies creating an environment that enables the subject (e.g., a process, system, or individual) to achieve its goals with less effort, time, or complexity.",
      "disambiguation_index": 0
    },
    "Predicate-is_closely_related_to": {
      "label": "is closely related to",
      "description": "The predicate 'is closely related to' indicates a connection between two entities where they share common characteristics, properties or concepts that are significant and relevant. This relationship suggests a strong association or affinity between the subject and object, implying that they have similar features, principles, or mechanisms.",
      "disambiguation_index": 0
    },
    "Predicate-recently_discovered_by": {
      "label": "recently discovered by",
      "description": "The predicate 'recently discovered by' indicates a relationship where someone (the subject) has found or identified something (the object), and another person (or entity) was involved in this process of discovery.",
      "disambiguation_index": 0
    },
    "Predicate-can_be_parsed_with": {
      "label": "can be parsed with",
      "description": "This predicate indicates a relationship between two entities where one entity (the subject) has its structure or organization analyzed and understood by another entity (the object), typically through the application of parsing rules, algorithms, or techniques.",
      "disambiguation_index": 0
    },
    "skos:broader": {
      "label": "has a broader term",
      "description": "The predicate 'has a broader term' indicates that the subject is a specific instance or example of a more general category or concept represented by the object. The relationship between the subject and object is one of instantiation, where the subject exemplifies or embodies the characteristics of the broader term.",
      "disambiguation_index": 0
    }
  }
}